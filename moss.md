# [Confidential] How did the teacher find out you were copying code?

Disclaimer: This video does not support academic misconduct in any sense, and is mainly intended to popularize how code checking works.

Hello everyone, welcome to my video. So with finals week approaching, many of you may have intentionally or unintentionally collaborated with others on code assignments due to stressful time constraints, and then mailed it in when the teacher found it. So have you ever wondered how the teacher actually finds out about people collaborating on code. Is there some way to check the code before submitting the assignment and then lower the weight to avoid the tragedy? So today a video can make it clear, the principle of code checking and how to lower the weight.

In this statement, this video does not support any sense of academic misconduct, the main purpose is to popularize the working principle of code checking.

As we all know, there are many platforms for checking our essays or papers, such as turnitin, so is there such a platform for code? Well, there is. This is the famous MOSS: Measure Of Software Similarity from Stanford, and as far as I know, most of the universities in the US are using this platform for code checking. But unlike turnitin, MOSS only provides a basic comparison between two pieces of code, and cannot search or compare other content on the Internet. So after talking to my computer science professor, I learned that generally speaking, each course at each school has its own database of all the code submitted by current and former students. Then after each assignment is submitted, the instructor usually runs a script that iterates through all the codes in the database and compares them. Codes with a similarity above a threshold are presented and marked as suspicious, which is usually enough for the instructor to manually go through the code again and almost always determine plagiarism or collaboration.

So how does MOSS determine the similarity of two codes? MOSS was introduced in 1994, contrary to what is happening now, when machine learning and deep learning were not on the rise. So MOSS is not an alchemy out of the program, and its principle is very simple: is the sieve algorithm (WINNOWING Algorithm). Here we have a very simple principle of popularization. First of all, MOSS will pre-process our text, that is, pre clean, so as to remove some of the characters that may interfere with the results, such as line breaks, spaces and so on. So it's useless to change the layout a little bit in order to reduce the weight of the code. The second step is to create a window. This window has a fixed length, sliding from the beginning to the end of the text. For each text in the window, we generate a hash value. So for the computer, or data structures are not so understanding of the partners will certainly ask, what is a hash? Hash can be understood as a function, it will give it different information are mapped to different unique numbers. Then hash is characterized by the input of the same text must get the same hash value, and input different text generally speaking will get different results. Here we do not discuss the problem of collision hash, so that hash can represent a text, a piece of information on the unique characteristics. Back to MOSS, then for the window generated by this pile of hash values, MOSS will select the smallest of several hash values, may be 5, or more, this is the most famous method of analyzing the similarity: that is, the minimum hash, minhash. in the minimum hash algorithm, select the smallest hash as a representative of the document, the value of the document to a certain degree to retain the important features. important features. Even if the content of the document has changed slightly, usually, the minimum hash value will remain relatively stable. Therefore, this minimum hash value can be used as a fingerprint of the document to identify and compare the similarity between documents. Then get the fingerprint of the two documents, MOSS will be for the two pieces of code Jaccard similarity calculation, that is, the intersection of the fingerprint of the two pieces of code divided by the concatenation, so that we can get a percentage of the similarity of the two pieces of code, is not very simple.

In order to allow you to understand the sieve algorithm, I also made a minimalist version of the text similarity detection site, placed on my personal website above: detect.haozheli.com, welcome to play.

Then after understanding the sieve algorithm, we can explain the vast majority of the problem.

First: for some code to change the variable name useful? Here I can clearly tell you, simply change the variable name is completely useless. This is because changing variable names will have no effect on the minimum hash value, as you can see from this example. I've changed all the variable names and MOSS is still able to accurately mark them as suspicious.

Second: Is it useful for me to change the order of the code functions? The answer is, it doesn't work either. This is because MOSS generates the hash value by sliding the window and then generating a hash value of the information in the window, so just changing the order of the code has no effect on the minimum hash value. Look at this example can also be seen, I will be A B two functions are interchanged, MOSS will be able to recognize it.

Third: so there is no way to make MOSS can not be recognized? Then there really is. Because MOSS is not an AI-based judgment program, it doesn't really understand a piece of code. If two pieces of code with different structures, or different text to achieve the same logic, MOSS is also unable to recognize. This includes, but is not limited to, replacing a traditional for loop with a Range-based for loop, rewriting an if statement, replacing an if else statement with a switch case or a three-eye operator, or disassembling a function into a helper function. a large number of these textual variations can invalidate MOSS. Let me tell you here that instead of using all these tricks I mentioned for your code, it is better to understand the code logic and write it yourself. So the fundamental solution to code checking is to understand the knowledge and write the code yourself.