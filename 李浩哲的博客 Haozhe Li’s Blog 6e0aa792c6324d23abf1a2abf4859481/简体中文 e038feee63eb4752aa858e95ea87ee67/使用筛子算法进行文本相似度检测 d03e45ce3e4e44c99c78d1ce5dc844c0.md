# 使用筛子算法进行文本相似度检测

[Read this article in English🇺🇸](../English%20cca26a332a7d4afe941bbcf116c60ade/Using%20WINNOWING%20Algorithm%20to%20detect%20text%20similarit%206a7648cfd3df4dcfac6fb2150e780c02.md)

# 目录

# 如何使用？

![2.jpg](%E4%BD%BF%E7%94%A8%E7%AD%9B%E5%AD%90%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E6%A3%80%E6%B5%8B%20d03e45ce3e4e44c99c78d1ce5dc844c0/2.jpg)

## 快速入门

您只需将两段文字（需英文）复制并粘贴到 [Detect.haozheli.com](http://detect.haozheli.com/)，然后点击立即检测按钮即可立即得到结果。

## 更准确地检测

以下两个小窍门可以让您的检测更准确。

- **输入更多字数：**使用检测器时，确保您的文本至少有 100 个字。字数越少，检测窗口越短，可能会产生意想不到的结果。
- **更改模型：** 要更改检测模式，请使用 "开始检测 "按钮旁边的选择框。建议使用默认模式。但如果您得到的结果是奇怪的，或者您乐于尝试，您可以将模式更改为严格或宽松模式。
- **重新开始:** 每次检测后，我都会建议您点击重新开始按钮。这将清除所有文本、结果、设置和缓存。这样您就可以轻松地开始检测下一项工作了。

## 阅读结果

下面我将讨论结果中每个元素的含义。

- **抄袭：**在这里，你应该得到一个简单的 "是 "或 "否 "的答案。这是对是否抄袭的总体考虑。
- **窗口大小：**这里您希望得到一个从 1 到 100 的整数。这表示为您自动生成的窗口大小。
- **相似性：**这里是两个文本相似的百分比。这是通过指纹交集计算得出的，因此并不意味着实际的文字交集。

# 如何工作？

[Detect.haozheli.com](http://detect.haozheli.com/)通过 javascript 实现[WINNOWING 算法](https://dl.acm.org/doi/10.1145/872757.872770)，在前端获取相似性报告。因此无需上传或存储任何数据或记录。此外，由于使用了 javascript，如果您对本网站进行了缓存，则可以离线使用本工具。

## 算法概述

**WINNOWING 算法**是一种局部文本相似性检测技术，用于在一组文档中识别重复或接近重复的段落。其操作方法是创建固定大小的文本 "窗口"，对这些窗口进行散列，然后在每个窗口内选择最小散列值。这些最小哈希值用于创建文档的指纹。通过比较不同文档的这些指纹，该算法可以识别出潜在的抄袭段落。

## 学术参考

我们计划实施的算法是**WINNOWING 算法**，用于文本抄袭检测。该算法在题为*"Winnowing：本文定义了该算法及其核心原理。[https://dl.acm.org/doi/10.1145/872757.872770。](https://dl.acm.org/doi/10.1145/872757.872770%E3%80%82)

为了方便我们阅读，这里是斯坦福大学网站上的 pdf 版本 [http://theory.stanford.edu/~aiken/publications/papers/sigmod03.pdf](http://theory.stanford.edu/~aiken/publications/papers/sigmod03.pdf)

它们完全相同。

## 源代码

从现在开始，我将讨论我的相似性检测器中使用的源代码。

### preprocessText 函数

- 这个函数用于清理输入的文本，避免有干扰信息。
- 这个函数会将遍历文本（字符串）中的每个字符，删除无用的符号，并且将所有的字母全部转换为小写。
- 函数会返回一个清理后的令牌列表。

```jsx

 // Preprocess the text: tokenize and convert to lowercase
function preprocessText(rawText) {
  let tokens = [];
  let token = "";

  for (let i = 0; i < rawText.length; i++) {
    let c = rawText[i];
    
    if (/[a-zA-Z0-9]/.test(c) || /[\u4e00-\u9fa5]/.test(c)) {
      if (/[A-Z]/.test(c)) {
        token += c.toLowerCase();
      } else {
        token += c;
      }
    } else if (token !== "") {
      tokens.push(token);
      token = "";
    }
  }

  if (token !== "") {
    tokens.push(token);
  }

  return tokens;
} 
```

### createWindows 函数

- 这个函数用于创建窗口。
- 这个函数将会根据windowSize创建一个窗口，在processedText中向后滑动。
- 函数会返回一个包含所有窗户的列表。

```jsx
// Create windows from the processed text
  function createWindows(processedText, windowSize) {
    let windows = [];
    for (let i = 0; i <= processedText.length - windowSize; i++) {
        let window = "";
        for (let j = i; j < i + windowSize; j++) {
            window += processedText[j];
            // Only add a space if it's not the last word in the window
            if (j < i + windowSize - 1) {
                window += " ";
            }
        }
        windows.push(window);
    }
    return windows;
  }
```

### hashWindows函数

- 这个函数会将每个窗口都声称一个哈希值
- 在这个函数中，我使用了非常简单的循环哈希：将哈希值乘31再加上字符的ascii值。这个哈希计算方式非常简陋，我会在日后更换其他方式。
- 将会返回一个哈希值列表。

```jsx
// Hash the windows using a simple hash function (you should replace this with a better hash function)
  function hashWindows(windows) {
    let hashes = [];
    for (let i = 0; i < windows.length; i++) {
        let hash = 0;
        for (let j = 0; j < windows[i].length; j++) {
            let c = windows[i].charCodeAt(j);
            hash = 31 * hash + c;
        }
        hashes.push(hash);
    }
    return hashes;
  }
```

### getFingerprints 函数

- 这个函数将哈希值放入一个集合，这将会剔除重复的哈希值。
- 返回一个叫做指纹的包含哈希值的集合。

```jsx
// Get the fingerprints from the hashes
  function getFingerprints(hashes) {
      let fingerprints = new Set();
      for (let i = 0; i < hashes.length; i++) {
      fingerprints.add(hashes[i]);
      }
      return fingerprints;
  }
```

### 检测敏感度以及detectPlagiarism 函数

- 代码的前七行用于获取用户选择的敏感度，以及相似度的声明。
- detectPlagiarism函数会计算两个文本的指纹交集，并计算出交集重合的百分比。如果这个百分比大于用户设定的敏感度阈值将会返回True，表明存在抄袭。
- detectPlagiarism会返回一个布尔运算值（True或者False）。

```jsx
let percentage = 0;
    const sensitivitySelect = document.getElementById('sensitivity');
    let sensitivity = 4;
    sensitivitySelect.addEventListener('change', function () {
        const selectedValue = sensitivitySelect.value;
        sensitivity = parseInt(selectedValue);
    });

    // Detect plagiarism by comparing the fingerprints
  function detectPlagiarism(fingerprints1, fingerprints2) {
    let intersection = new Set([...fingerprints1].filter(x => fingerprints2.has(x)));
    let intersectionSize = intersection.size;
    let union = new Set([...fingerprints1, ...fingerprints2]);
    let unionSize = union.size;
    let similarity = intersectionSize / unionSize;
    percentage = similarity * 100;
    return percentage > sensitivity;
  }
```

### runPlagiarismDetection 函数

- 这个函数将会运行上面所有的函数，并展示结果

```jsx
function runPlagiarismDetection() {
    // Get the input text from the textboxes
    let text1 = document.getElementById("text1").value;
    let text2 = document.getElementById("text2").value;

    // Preprocess the texts
    let processedText1 = preprocessText(text1);
    let processedText2 = preprocessText(text2);

    let windowSize = text1.length < text2.length ? Math.floor(text1.length / 10) : Math.floor(text2.length / 10);
    if (windowSize < 1) {
      windowSize = 1;
    }
    if (windowSize > 100) {
      windowSize = 100;
    }

    document.getElementById("windowsize").innerText = windowSize;

    // Create windows
    let windows1 = createWindows(processedText1, windowSize);
    let windows2 = createWindows(processedText2, windowSize);

    // Hash the windows
    let hashes1 = hashWindows(windows1);
    let hashes2 = hashWindows(windows2);

    // Get the fingerprints
    let fingerprints1 = getFingerprints(hashes1);
    let fingerprints2 = getFingerprints(hashes2);

    // Detect plagiarism
    let isPlagiarized = detectPlagiarism(fingerprints1, fingerprints2);
    document.getElementById("fg").innerText = Math.floor(percentage) + "%";

// Display the result
    document.getElementById("result").innerText = isPlagiarized ? "存在" : "不存在";
  }
```

# 结尾

恭喜你看到这里！这里已经是文章的结尾，希望你已经会使用Similarity Detector，以及了解它是如何工作的。如果有任何问题，欢迎在文章中评论，或者是前往我的网站 [haozheli.com](https://www.haozheli.com) 联系笔者。